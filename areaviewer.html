<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>ARea Kamera-AR Viewer</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

<div id="err"></div>

<!-- Startscreen wie beim WebXR-Viewer, inkl. Girlande -->
<div id="start-screen">
  <div id="start-content">
    <div id="start-card">
      <div id="ar-experience-label">AR EXPERIENCE</div>
      <h1 id="start-title"></h1>
      <p id="start-subline"></p>
      <img id="start-image" style="display:none;" alt="Vorschau"/>
      <p id="start-text"></p>
      <button class="btn-start" id="btn-enter-ar">STARTE AR‚ú®</button>
    </div>
    <img id="tannengruen-frame" src="./assets/Tannengruen.png" alt="Dekorativer Tannengr√ºn-Rahmen" aria-hidden="true"/>
  </div>
</div>

<!-- Kamerabild (wird als Texture in Three genutzt) -->
<video id="camera-video" playsinline autoplay muted></video>

<!-- Overlay-UI (gleiche Struktur wie webxr.html) -->
<div id="overlay">
  <div class="ui-row">
    <button class="btn-icon" id="btn-close" aria-label="AR-Session beenden">√ó</button>
    <button class="btn-icon" id="btn-mute" style="display:none" aria-label="Audio umschalten">üîä</button>
  </div>

  <!-- Galerie-Overlay -->
  <div id="gallery-panel" aria-hidden="true">
    <div id="gallery-inner">
      <header id="gallery-header">
        <span>Aufnahmen</span>
        <button id="gallery-close" type="button" aria-label="Galerie schlie√üen">‚úï</button>
      </header>

      <div id="gallery-body">
        <section id="gallery-preview">
          <div id="gallery-preview-media"></div>
          <div id="gallery-meta">
            <div id="gallery-filename"></div>
            <button id="gallery-download" type="button">
              Download / Teilen
            </button>
          </div>
        </section>

        <section id="gallery-grid"></section>
      </div>
    </div>
  </div>

  <!-- Aufnahme + Galerie -->
  <div id="ar-capture-controls">
    <!-- EIN Haupt-Button: kurz = Foto, lang = Video -->
    <button id="btn-main-capture" class="btn-capture" type="button"
            aria-label="Foto (tippen) oder Video (halten)">
      <svg id="progress-ring" viewBox="0 0 80 80" width="80" height="80">
        <circle id="progress-circle" cx="40" cy="40" r="34"></circle>
      </svg>
      <span id="capture-icon">üì∏</span>
    </button>

    <!-- Kleiner Galerie-Button -->
    <button id="btn-gallery-small" class="btn-capture btn-gallery" type="button"
            aria-label="Aufnahmen anzeigen">
      üñºÔ∏è
    </button>
  </div>

  <div id="msg-container">
    <div id="msg" role="status" aria-live="polite">Tippe auf die Zielmarkierung, um das Modell zu platzieren.</div>
  </div>

  <div id="gesture-layer"></div>
</div>

<audio id="ar-audio" loop playsinline preload="auto" crossorigin="anonymous"></audio>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { DeviceOrientationControls } from './js/DeviceOrientationControls.js';


// --- Grund-Variablen (analog webxr.html) ---
let camera, scene, renderer;
let controls;
let placementGroup;
let placementRect;
let model;
let mixer;
const clock = new THREE.Clock();

let isModelPlaced = false;
let modelLoaded = false;
let isEditing = false;
let isHovering = false;

let currentTouches = [];
let gestureStartTime = 0;
let tapStartX = 0;
let tapStartY = 0;
let didMove = false;
let isDraggingModel = false;
let isRotatingModel = false;
let isScalingModel = false;

const ROTATION_FACTOR = 0.018;
const SCALE_FACTOR = 0.005;
const DRAG_THRESHOLD_PIX = 18;
const TAP_THRESHOLD_MS = 350;
const RECT_SIZE = 0.5;

let initialPinchDistance = 0;
let initialModelScale = 1;
let lastMoveX = 0;

const raycaster = new THREE.Raycaster();
const ndc = new THREE.Vector2();
const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

// Szene / Worker-URLs
const qs = new URLSearchParams(location.search);
const workerBase = (qs.get('base') || 'https://area-publish-proxy.area-webar.workers.dev').replace(/\/$/, '');
const sceneParam = qs.get('scene') || qs.get('src');
let SCENE_JSON_URL = '';
let MODEL_URL = '';
let AUDIO_URL = '';

// Audio
const audioEl = document.getElementById('ar-audio');
const btnMute = document.getElementById('btn-mute');
let isMuted = false;
let audioCtx = null;

function ensureAudioUnlocked() {
  try {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
  } catch (e) {
    console.warn('AudioContext konnte nicht initialisiert werden:', e);
  }
}

async function tryStartAudioIfPossible() {
  if (!AUDIO_URL || isMuted) return;
  try {
    ensureAudioUnlocked();
    if (audioEl.paused) await audioEl.play();
  } catch (_) {}
}

function setupAudio(audioCfg) {
  btnMute.style.display = 'flex';
  btnMute.textContent = 'üîä';
  btnMute.setAttribute('aria-label', 'Audio ausschalten');
  audioEl.crossOrigin = 'anonymous';
  audioEl.src = AUDIO_URL;
  audioEl.loop = !!audioCfg.loop;

  const sceneVolume =
    (audioCfg && typeof audioCfg.volume === 'number')
      ? audioCfg.volume
      : 0.8;

  const masterVolume = 0.3;
  audioEl.volume = sceneVolume * masterVolume;

  try { audioEl.load(); } catch(e) {}

  audioEl.addEventListener('error', (e) => {
    console.error('Audio load error:', e);
    setUiState('audio_error', 'Audio konnte nicht geladen werden (CORS/Netzwerk).');
  });

  btnMute.onclick = async () => {
    isMuted = !isMuted;
    audioEl.muted = isMuted;
    btnMute.textContent = isMuted ? 'üîá' : 'üîä';
    btnMute.setAttribute('aria-label', isMuted ? 'Audio einschalten' : 'Audio ausschalten');
    if (!isMuted) {
      ensureAudioUnlocked();
      try {
        await audioEl.play();
        setUiState('audio_playing', 'Audio l√§uft.');
      } catch {
        setUiState('audio_blocked', 'Audio blockiert. Versuche es ggf. erneut.');
      }
    } else {
      audioEl.pause();
    }
  };
}

// --- UI Helpers ---
function showErr(txt) {
  const e = document.getElementById('err');
  e.textContent = txt;
  e.style.display = 'block';
  setTimeout(() => e.style.display='none', 5000);
}

let uiState = '';
function updateMsg(txt) {
  document.getElementById('msg').textContent = txt;
}
function setUiState(nextState, msg) {
  if (uiState !== nextState) {
    uiState = nextState;
    if (msg !== undefined && msg !== null && msg !== '') {
      updateMsg(msg);
    }
  }
}

function toNDC(clientX, clientY) {
  const w = renderer.domElement.clientWidth || window.innerWidth;
  const h = renderer.domElement.clientHeight || window.innerHeight;
  ndc.x = (clientX / w) * 2 - 1;
  ndc.y = -(clientY / h) * 2 + 1;
}

function isTapInsidePlacementRect(clientX, clientY) {
  if (!placementGroup || !placementRect || !placementRect.visible || !isHovering) return false;
  toNDC(clientX, clientY);
  raycaster.setFromCamera(ndc, camera);
  const hit = new THREE.Vector3();
  if (raycaster.ray.intersectPlane(floorPlane, hit) === null) return false;
  const rectWorldPos = placementGroup.position;
  const dx = hit.x - rectWorldPos.x;
  const dz = hit.z - rectWorldPos.z;
  const halfSize = (RECT_SIZE * placementGroup.scale.x * 1.05) / 2 + 0.05;
  return (Math.abs(dx) <= halfSize) && (Math.abs(dz) <= halfSize);
}

function isTouchOnModel(clientX, clientY) {
  if (!model || !isModelPlaced) return false;
  toNDC(clientX, clientY);
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObject(model, true);
  return hits.length > 0;
}

// --- Kamera-Stream / VideoTexture ---
let videoEl = null;
let videoTexture = null;

async function initCameraStream() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    throw new Error('Kamera-Zugriff wird nicht unterst√ºtzt.');
  }

  videoEl = document.getElementById('camera-video');

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: 'environment' } },
    audio: false
  });

  videoEl.srcObject = stream;
  await videoEl.play();

  videoTexture = new THREE.VideoTexture(videoEl);
  videoTexture.colorSpace = THREE.SRGBColorSpace;
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.encoding = THREE.sRGBEncoding;

  scene.background = videoTexture;
}

function stopCameraStream() {
  if (videoEl && videoEl.srcObject) {
    const tracks = videoEl.srcObject.getTracks();
    tracks.forEach(t => t.stop());
    videoEl.srcObject = null;
  }
}

// --- Capture & Galerie (Canvas-basiert ‚Äì kein getDisplayMedia mehr!) ---
function initCaptureAndGallery({ renderer, audioEl }) {
  const captureBtn = document.getElementById('btn-main-capture');
  const captureIcon = document.getElementById('capture-icon');
  const progressCircle = document.getElementById('progress-circle');

  const galleryBtn = document.getElementById('btn-gallery-small');
  const galleryPanel = document.getElementById('gallery-panel');
  const galleryGrid = document.getElementById('gallery-grid');
  const galleryPreview = document.getElementById('gallery-preview-media');
  const galleryFilenameEl = document.getElementById('gallery-filename');
  const galleryDownloadBtn = document.getElementById('gallery-download');
  const galleryCloseBtn = document.getElementById('gallery-close');

  if (!captureBtn) {
    console.warn('[ARea] Capture-Button nicht gefunden.');
    return;
  }

  const LONG_PRESS_MS = 550;
  let pressTimer = null;
  let longPressActive = false;
  let isRecording = false;

  let canvasStream = null;
  let canvasRecorder = null;
  let screenChunks = [];

  const galleryItems = [];
  let currentPreviewIndex = -1;

  // Progress-Ring
  let circleCirc = 0;
  if (progressCircle) {
    const r = progressCircle.r.baseVal.value || 34;
    circleCirc = 2 * Math.PI * r;
    progressCircle.style.strokeDasharray = `${circleCirc}`;
    progressCircle.style.strokeDashoffset = `${circleCirc}`;
  }

  function setProgress(p) {
    if (!progressCircle || !circleCirc) return;
    const clamped = Math.min(Math.max(p, 0), 1);
    progressCircle.style.strokeDashoffset = `${circleCirc * (1 - clamped)}`;
  }

  function resetProgress() {
    setProgress(0);
  }

  function setCaptureIcon(mode) {
    if (!captureIcon) return;
    if (mode === 'video') {
      captureIcon.textContent = '‚èπÔ∏è';
      captureBtn.classList.add('is-recording');
    } else {
      captureIcon.textContent = 'üì∏';
      captureBtn.classList.remove('is-recording');
      resetProgress();
    }
  }

  function makeFilename(kind, ext) {
    const now = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const stamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
    const base = kind === 'image' ? 'area-ar-photo' : 'area-ar-video';
    return `${base}-${stamp}.${ext || (kind === 'image' ? 'png' : 'webm')}`;
  }

  async function tryShareOrDownload(blob, filename) {
    try {
      const file = new File([blob], filename, { type: blob.type });
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: filename
        });
        return;
      }
    } catch (err) {
      console.warn('[ARea] Native Share nicht m√∂glich oder abgebrochen', err);
    }

    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function addToGallery(kind, blob, filename) {
    const url = URL.createObjectURL(blob);
    const item = {
      kind,
      blob,
      url,
      filename,
      createdAt: new Date()
    };
    galleryItems.push(item);
    updateGalleryGrid();
    updateGalleryButtonThumb(item);
  }

  function updateGalleryButtonThumb(item) {
    if (!galleryBtn) return;
    if (item.kind === 'image') {
      galleryBtn.style.backgroundImage = `url(${item.url})`;
      galleryBtn.style.backgroundSize = 'cover';
      galleryBtn.style.backgroundPosition = 'center';
      galleryBtn.textContent = '';
    } else {
      galleryBtn.style.backgroundImage = '';
      galleryBtn.textContent = 'üñºÔ∏è';
    }
  }

  function updateGalleryGrid() {
    if (!galleryGrid) return;
    galleryGrid.innerHTML = '';
    galleryItems.forEach((item, index) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'gallery-thumb';
      if (item.kind === 'image') {
        btn.style.backgroundImage = `url(${item.url})`;
      } else {
        btn.classList.add('is-video');
      }
      btn.addEventListener('click', () => openPreview(index));
      galleryGrid.appendChild(btn);
    });
  }

  function openPreview(index) {
    if (!galleryPanel || !galleryPreview || !galleryFilenameEl || !galleryDownloadBtn) return;
    const item = galleryItems[index];
    if (!item) return;

    galleryPreview.innerHTML = '';
    let node;
    if (item.kind === 'image') {
      const img = document.createElement('img');
      img.src = item.url;
      img.alt = item.filename;
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
      node = img;
    } else {
      const video = document.createElement('video');
      video.src = item.url;
      video.controls = true;
      video.autoplay = true;
      video.style.maxWidth = '100%';
      video.style.maxHeight = '100%';
      node = video;
    }
    galleryPreview.appendChild(node);
    galleryFilenameEl.textContent = item.filename;
    galleryDownloadBtn.onclick = () => tryShareOrDownload(item.blob, item.filename);
    currentPreviewIndex = index;
    galleryPanel.dataset.open = 'true';
  }

  function closeGallery() {
    if (!galleryPanel) return;
    galleryPanel.dataset.open = 'false';
  }

  function wireGallery() {
    if (galleryBtn) {
      galleryBtn.addEventListener('click', () => {
        if (!galleryItems.length) return;
        openPreview(galleryItems.length - 1);
      });
    }
    if (galleryCloseBtn) {
      galleryCloseBtn.addEventListener('click', () => closeGallery());
    }
    if (galleryPanel) {
      galleryPanel.addEventListener('click', (ev) => {
        if (ev.target === galleryPanel) {
          closeGallery();
        }
      });
    }
  }

  function captureCanvasFrame() {
    return new Promise((resolve, reject) => {
      try {
        renderer.domElement.toBlob(
          (blob) => {
            if (blob) resolve(blob);
            else reject(new Error('Canvas Screenshot fehlgeschlagen'));
          },
          'image/png'
        );
      } catch (err) {
        reject(err);
      }
    });
  }

  async function makePhotoBlob() {
    // IMMER Canvas (enth√§lt Kamera + 3D)
    return await captureCanvasFrame();
  }

  async function startVideoCapture() {
    try {
      canvasStream = renderer.domElement.captureStream(30);

      const candidates = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      let mimeType = '';
      for (const cand of candidates) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(cand)) {
          mimeType = cand;
          break;
        }
      }

      screenChunks = [];
      canvasRecorder = new MediaRecorder(
        canvasStream,
        mimeType ? { mimeType } : {}
      );
      canvasRecorder.ondataavailable = (ev) => {
        if (ev.data && ev.data.size > 0) {
          screenChunks.push(ev.data);
        }
      };
      canvasRecorder.onstop = () => {
        try {
          const blob = new Blob(screenChunks, {
            type: mimeType || 'video/webm'
          });
          const filename = makeFilename('video', 'webm');
          onCaptureReady('video', blob, filename);
        } catch (err) {
          console.error('[ARea] Fehler beim Erzeugen der Videodatei', err);
        } finally {
          if (canvasStream) {
            canvasStream.getTracks().forEach((t) => t.stop());
          }
          canvasStream = null;
          canvasRecorder = null;
          screenChunks = [];
        }
      };

      canvasRecorder.start();
      return true;
    } catch (err) {
      console.error('[ARea] Videoaufnahme konnte nicht gestartet werden', err);
      return false;
    }
  }

  function stopVideoCapture() {
    if (canvasRecorder && canvasRecorder.state !== 'inactive') {
      canvasRecorder.stop();
    }
  }

  async function onCaptureReady(kind, blob, filename) {
    if (!blob) return;
    const finalFilename = filename || makeFilename(kind);
    addToGallery(kind, blob, finalFilename);
    await tryShareOrDownload(blob, finalFilename);
  }

  async function handleTapCapture() {
    if (isRecording) return;
    captureBtn.disabled = true;
    try {
      const blob = await makePhotoBlob();
      await onCaptureReady('image', blob);
    } catch (err) {
      console.error('[ARea] Screenshot fehlgeschlagen', err);
    } finally {
      captureBtn.disabled = false;
      setCaptureIcon('photo');
    }
  }

  async function handleStart(ev) {
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    if (isRecording) return;

    longPressActive = false;
    let startTime = performance.now();

    pressTimer = window.setTimeout(async () => {
      longPressActive = true;
      isRecording = true;
      setCaptureIcon('video');
      setProgress(0);

      const ok = await startVideoCapture();
      if (!ok) {
        isRecording = false;
        longPressActive = false;
        setCaptureIcon('photo');
      }
    }, LONG_PRESS_MS);

    const animate = () => {
      if (!pressTimer || longPressActive || isRecording) {
        setProgress(0);
        return;
      }
      const elapsed = performance.now() - startTime;
      const p = Math.min(elapsed / LONG_PRESS_MS, 1);
      setProgress(p);
      if (p < 1 && pressTimer) {
        requestAnimationFrame(animate);
      }
    };
    requestAnimationFrame(animate);
  }

  async function handleEnd(ev) {
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }

    if (pressTimer) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }

    const wasLong = longPressActive;
    const wasRecording = isRecording;
    longPressActive = false;

    if (wasRecording) {
      stopVideoCapture();
      isRecording = false;
      setCaptureIcon('photo');
      resetProgress();
      return;
    }

    if (!wasLong) {
      await handleTapCapture();
    }
  }

  captureBtn.addEventListener('touchstart', handleStart, { passive: false });
  captureBtn.addEventListener('touchend', handleEnd, { passive: false });
  captureBtn.addEventListener('mousedown', handleStart);
  captureBtn.addEventListener('mouseup', handleEnd);
  captureBtn.addEventListener('mouseleave', handleEnd);

  setCaptureIcon('photo');
  wireGallery();

  console.log('[ARea] Kamera-AR Capture + Gallery initialisiert');
}

// --- Three.js Setup ---
function initThree() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);
  camera.position.set(0, 1.5, 0);
  camera.lookAt(0, 1.5, -1);

  controls = new DeviceOrientationControls(camera);

  const hemi = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1.2);
  scene.add(hemi);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
  dirLight.position.set(2, 8, 4);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024, 1024);
  scene.add(dirLight);

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
    preserveDrawingBuffer: true
  });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  placementGroup = new THREE.Group();
  placementGroup.visible = false;
  scene.add(placementGroup);

  const shadowPlaneGeo = new THREE.PlaneGeometry(10, 10);
  shadowPlaneGeo.rotateX(-Math.PI / 2);
  const shadowPlaneMat = new THREE.ShadowMaterial({ opacity: 0.3 });
  const shadowPlane = new THREE.Mesh(shadowPlaneGeo, shadowPlaneMat);
  shadowPlane.position.y = 0;
  shadowPlane.receiveShadow = true;
  scene.add(shadowPlane);

  const radius = 0.05;
  const rectShape = new THREE.Shape();
  rectShape.moveTo(0, radius);
  rectShape.lineTo(0, RECT_SIZE - radius);
  rectShape.quadraticCurveTo(0, RECT_SIZE, radius, RECT_SIZE);
  rectShape.lineTo(RECT_SIZE - radius, RECT_SIZE);
  rectShape.quadraticCurveTo(RECT_SIZE, RECT_SIZE, RECT_SIZE, RECT_SIZE - radius);
  rectShape.lineTo(RECT_SIZE, radius);
  rectShape.quadraticCurveTo(RECT_SIZE, 0, RECT_SIZE - radius, 0);
  rectShape.lineTo(radius, 0);
  rectShape.quadraticCurveTo(0, 0, 0, radius);
  const outlineGeo = new THREE.ShapeGeometry(rectShape);
  outlineGeo.translate(-RECT_SIZE / 2, -RECT_SIZE / 2, 0);
  const edges = new THREE.EdgesGeometry(outlineGeo);
  const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true });
  placementRect = new THREE.LineSegments(edges, lineMat);
  placementRect.rotation.x = -Math.PI / 2;
  placementRect.position.y = 0.005;
  placementRect.scale.set(1.05, 1.05, 1.05);
  placementRect.visible = false;
  placementGroup.add(placementRect);
}

async function loadModel() {
  const loader = new GLTFLoader();
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);

  try {
    const gltf = await loader.loadAsync(MODEL_URL);
    model = gltf.scene;
    model.traverse((node) => {
      if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = false;
      }
    });
    model.scale.setScalar(0.5);
    if (gltf.animations?.length) {
      mixer = new THREE.AnimationMixer(model);
      gltf.animations.forEach(clip => mixer.clipAction(clip).play());
    }
    placementGroup.add(model);
    modelLoaded = true;
    setUiState('loaded', 'Modell geladen. Tippe auf AR Starten.');
  } catch (e) {
    throw new Error(e.message || 'Unbekannter Fehler beim Laden des 3D-Modells.');
  }
}

let renderRunning = false;
function startRenderLoop() {
  if (renderRunning) return;
  renderRunning = true;

  function loop() {
    if (!renderRunning) return;

    const dt = clock.getDelta();
    if (mixer) mixer.update(dt);
    if (controls) controls.update();

    if (videoTexture && videoEl && videoEl.readyState >= videoEl.HAVE_CURRENT_DATA) {
      videoTexture.needsUpdate = true;
    }

    if (!isModelPlaced) {
      // Reticle auf Boden in Blickrichtung im Zentrum
      ndc.set(0, 0);
      raycaster.setFromCamera(ndc, camera);
      const hit = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(floorPlane, hit)) {
        placementGroup.position.copy(hit);
        placementGroup.position.y = 0;
        placementGroup.visible = true;
        placementRect.visible = true;
        isHovering = true;
        setUiState('hover', 'Tippe auf die Zielmarkierung, um das Modell zu platzieren.');
      } else {
        placementGroup.visible = false;
        placementRect.visible = false;
        isHovering = false;
        setUiState('search', 'Suche Boden...');
      }
    } else {
      placementRect.visible = isEditing;
    }

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
}

function stopRenderLoop() {
  renderRunning = false;
}

function onResize() {
  if (!renderer || !camera) return;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- Gesten (wie im WebXR-Viewer) ---
function getDistance(touch1, touch2) {
  return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
}

function onTouchStart(event) {
  currentTouches = event.touches ? Array.from(event.touches) : [event];
  if (currentTouches.length === 0) return;

  gestureStartTime = performance.now();
  didMove = false;
  isEditing = false;

  tapStartX = currentTouches[0].clientX;
  tapStartY = currentTouches[0].clientY;
  lastMoveX = tapStartX;

  isDraggingModel = false;
  isRotatingModel = false;
  isScalingModel = false;

  if (!isModelPlaced) return;

  if (currentTouches.length === 2) {
    isEditing = true;
    isScalingModel = true;
    initialPinchDistance = getDistance(currentTouches[0], currentTouches[1]);
    initialModelScale = placementGroup.scale.x;
    placementRect.visible = true;
    setUiState('scale', 'Skalieren (Pinch)');
  } else if (currentTouches.length === 1) {
    if (isTouchOnModel(tapStartX, tapStartY)) {
      isEditing = true;
      isDraggingModel = true;
      placementRect.visible = true;
      setUiState('drag', 'Modell verschieben (Drag)');
    } else {
      isEditing = true;
      isRotatingModel = true;
      placementRect.visible = true;
      setUiState('rotate', 'Modell drehen (Swipe)');
    }
  }

  if (isEditing) event.preventDefault();
}

function onTouchMove(event) {
  currentTouches = event.touches ? Array.from(event.touches) : [event];
  const touchCount = currentTouches.length;

  if (isEditing || touchCount > 1) event.preventDefault();
  if (!isEditing || !isModelPlaced) return;

  const isTwoFinger = touchCount === 2;
  const isOneFinger = touchCount === 1;

  const dragDistanceTotal = Math.hypot(currentTouches[0].clientX - tapStartX, currentTouches[0].clientY - tapStartY);
  if (dragDistanceTotal > DRAG_THRESHOLD_PIX) didMove = true;

  if (isTwoFinger) {
    if (!isScalingModel) {
      isScalingModel = true;
      isDraggingModel = false;
      isRotatingModel = false;
      initialPinchDistance = getDistance(currentTouches[0], currentTouches[1]);
      initialModelScale = placementGroup.scale.x;
      setUiState('scale', 'Skalieren (Pinch)');
    }
    const newDist = getDistance(currentTouches[0], currentTouches[1]);
    const scaleDelta = newDist - initialPinchDistance;
    const newScale = initialModelScale + scaleDelta * SCALE_FACTOR;
    const clamped = Math.max(0.25, Math.min(3.0, newScale));
    placementGroup.scale.setScalar(clamped);
  } else if (isScalingModel && isOneFinger) {
    isScalingModel = false;
    const t = currentTouches[0];
    if (isTouchOnModel(t.clientX, t.clientY)) {
      isDraggingModel = true;
      isRotatingModel = false;
      setUiState('drag', 'Modell verschieben (Drag)');
    } else {
      isDraggingModel = false;
      isRotatingModel = true;
      setUiState('rotate', 'Modell drehen (Swipe)');
    }
  } else if (isOneFinger) {
    const t = currentTouches[0];
    const dx = t.clientX - lastMoveX;

    if (isDraggingModel) {
      toNDC(t.clientX, t.clientY);
      raycaster.setFromCamera(ndc, camera);
      const hit = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(floorPlane, hit)) {
        placementGroup.position.set(hit.x, 0, hit.z);
      }
    }
    if (isRotatingModel) {
      placementGroup.rotation.y += dx * ROTATION_FACTOR;
    }

    lastMoveX = t.clientX;
  }
}

function onTouchEnd(event) {
  if (event.touches && event.touches.length > 0) return;

  const gestureDuration = performance.now() - gestureStartTime;
  const isTap = !didMove && gestureDuration < TAP_THRESHOLD_MS;
  const endedTouch = event.changedTouches ? event.changedTouches[0] : event;

  if (!isModelPlaced && isTap) {
    if (isHovering && isTapInsidePlacementRect(endedTouch.clientX, endedTouch.clientY)) {
      isModelPlaced = true;
      placementRect.visible = false;
      setUiState('placed', 'Modell platziert. Ziehen/Pinch zum Bearbeiten.');
    }
  }

  if (isEditing) {
    isEditing = false;
    isDraggingModel = false;
    isRotatingModel = false;
    isScalingModel = false;
    initialModelScale = placementGroup.scale.x;
    placementRect.visible = false;
    if (isModelPlaced) setUiState('placed', 'Bearbeitung beendet. Tippe auf Modell zum erneuten Draggen.');
  }
}

// --- Reset ---
function resetARState() {
  const startScreen = document.getElementById('start-screen');
  const overlay = document.getElementById('overlay');
  const btnEnterAR = document.getElementById('btn-enter-ar');

  if (controls) {
    controls.disconnect(); // Events abr√§umen
  }
  stopRenderLoop();
  stopCameraStream();
  audioEl.pause();

  startScreen.style.display = 'flex';
  overlay.style.pointerEvents = 'none';

  isModelPlaced = false;
  isEditing = false;
  placementGroup.visible = false;
  placementRect.visible = false;
  btnEnterAR.disabled = !modelLoaded;
  setUiState('initial', 'Tippe auf die Zielmarkierung, um das Modell zu platzieren.');
}

// --- Boot ---
async function boot() {
  const startScreen = document.getElementById('start-screen');
  const overlay = document.getElementById('overlay');
  const btnEnterAR = document.getElementById('btn-enter-ar');
  const startImage = document.getElementById('start-image');

  const startTitle = document.getElementById('start-title');
  const startSubline = document.getElementById('start-subline');
  const startText = document.getElementById('start-text');

  startScreen.style.display = 'flex';
  overlay.style.pointerEvents = 'none';
  btnEnterAR.disabled = true;

  startTitle.textContent = '';
  startSubline.textContent = '';
  startText.textContent = '';
  startImage.style.display = 'none';

  if (sceneParam) {
    if (sceneParam.endsWith('.glb')) {
      MODEL_URL = sceneParam;
    } else {
      SCENE_JSON_URL = `${workerBase}/scenes/${sceneParam}/scene.json`;
    }
  } else {
    MODEL_URL = 'https://modelviewer.dev/shared-assets/models/Astronaut.glb';
  }

  if (SCENE_JSON_URL) {
    try {
      const res = await fetch(SCENE_JSON_URL);
      if (!res.ok) throw new Error(`Scene JSON Error: ${res.status} ${res.statusText}`);
      const json = await res.json();

      const meta    = json.meta || {};
      const welcome = (json.ui && json.ui.welcome) || {};
      const title =
        (meta.title && meta.title.trim()) ||
        (welcome.title && welcome.title.trim()) ||
        '';

      const subline =
        (meta.subtitle && meta.subtitle.trim()) ||
        (welcome.eyebrow && welcome.eyebrow.trim()) ||
        '';

      const body =
        (meta.body && meta.body.trim()) ||
        (meta.description && meta.description.trim()) ||
        (welcome.desc && welcome.desc.trim()) ||
        '';

      const posterFile =
        (meta.posterImage && String(meta.posterImage).trim()) ||
        (welcome.poster && String(welcome.poster).trim()) ||
        '';

      startTitle.innerHTML = title;
      startSubline.innerHTML = subline;
      startText.innerHTML = body;

      if (posterFile) {
        const imageUrl = `${workerBase}/scenes/${sceneParam}/${encodeURIComponent(posterFile)}`;
        startImage.src = imageUrl;
        startImage.style.display = 'block';
        startImage.alt = title ? `${title} Vorschau` : 'Vorschau';
      } else {
        startImage.style.display = 'none';
      }

      if (json.model?.url) {
        MODEL_URL = `${workerBase}/scenes/${sceneParam}/${json.model.url}`;
      } else {
        MODEL_URL = 'https://modelviewer.dev/shared-assets/models/Astronaut.glb';
        showErr('Hinweis: Szene-JSON enth√§lt keine Modell-URL. Fallback-Modell wird verwendet.');
      }

      if (json.audio?.url) {
        AUDIO_URL = `${workerBase}/scenes/${sceneParam}/${json.audio.url}`;
        setupAudio(json.audio);
      }
    } catch (e) {
      console.error(e);
      showErr('Fehler beim Laden der Szene-Konfiguration: ' + e.message);
    }
  }

  initThree();

  try {
    await loadModel();
  } catch (e) {
    showErr('Modell-Ladefehler: ' + e.message);
    console.error('Modell-Ladefehler:', e);
    btnEnterAR.disabled = true;
    return;
  }

  initCaptureAndGallery({
    renderer,
    audioEl: document.getElementById('ar-audio')
  });

  btnEnterAR.disabled = false;
  setUiState('loaded', 'Modell geladen. Tippe auf AR Starten.');

  window.addEventListener('resize', onResize);

  btnEnterAR.addEventListener('click', async () => {
    if (!modelLoaded) {
      showErr('Modell noch nicht vollst√§ndig geladen. Bitte warten Sie kurz.');
      return;
    }

    if (AUDIO_URL && !isMuted) {
      ensureAudioUnlocked();
      try {
        await audioEl.play();
        setUiState('audio_playing', 'Audio l√§uft.');
      } catch (e) {
        setUiState('audio_blocked', 'Audio blockiert. Tippe auf üîä zum Abspielen.');
      }
    }

    startScreen.style.display = 'none';
    overlay.style.pointerEvents = 'auto';

    try {
    await initCameraStream();

    if (controls) {
      controls.connect();   // DeviceOrientation-Events aktivieren
    }

    startRenderLoop();
  } catch (err) {
      console.error(err);
      showErr('Kamera konnte nicht gestartet werden: ' + (err.message || err));
      resetARState();
    }
  });

  document.getElementById('btn-close').addEventListener('click', () => {
    resetARState();
  });

  const gestureLayer = document.getElementById('gesture-layer');
  gestureLayer.addEventListener('touchstart', onTouchStart, { passive: false });
  gestureLayer.addEventListener('touchmove', onTouchMove, { passive: false });
  gestureLayer.addEventListener('touchend', onTouchEnd, { passive: false });
  gestureLayer.addEventListener('touchcancel', onTouchEnd, { passive: false });
  gestureLayer.addEventListener('mousedown', onTouchStart, { passive: false });
  gestureLayer.addEventListener('mousemove', onTouchMove, { passive: false });
  gestureLayer.addEventListener('mouseup', onTouchEnd, { passive: false });
}

boot();
</script>

</body>
</html>
